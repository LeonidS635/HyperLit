# HyperLit

_HyperLit_ — это инструмент, предназначенный для отслеживания актуальности документации по отношению к исходному коду.

## Описание

Проект направлен на решение проблемы устаревания программной документации. Часто документация ведётся отдельно
от кода, что затрудняет процесс поддержания её в актуальном состоянии. _HyperLit_ объединяет код и соответствующие ему
комментарии в единую иерархическую структуру и позволяет:
- работать на уровне логических секций (пары “код + комментарий”), а не целых файлов
- выявлять потенциально устаревшие участки кода или документации
- генерировать интерактивную HTML-документацию с иерархией и навигацией

## Основные свойства и возможности

- Независимость от языка программирования
- Разметка секций с кодом и документацией с помощью специального синтаксиса
- Хранение секций в структуре, вдохновлённой Git
- Ленивое и асинхронное сравнение секций
- Отслеживание изменений в коде и документации
- Генерация HTML-документации, повторяющей структуру проекта, и навигацией по гиперссылкам
- CLI интерфейс

## Использование

_HyperLit_ представляет собой консольную утилиту, имеющая следующие команды:
- `commit`
    ```bash
    hl commit
    ```
    Команда `commit` выполняет анализ и сравнение секций в исходном коде проекта. По завершении проверки пользователь получит
    список изменённых секций с указанием их статуса. После этого система предложит сохранить изменения либо отказаться от сохранения,
    чтобы пользователь мог обновить устаревшие фрагменты кода или документации.
- `docs`
    ```bash
    hl docs [flags]
  
    Flags:
      -m, --markdown   generate markdown documentation (default true)
      -p, --port       port to listen on (default 8123)
    ```
    Команда `docs` поднимает локальный сервер для просмотра документации. Он по умолчанию доступен на порту 8123.

## Архитектура

Система состоит из четырёх основных компонентов: парсинг, хранение и сравнение секций, а также генерация документации.

#### Парсинг секций

Для корректной работы весь код и соответствующая ему документация должны быть размечены с использованием специального
синтаксиса. Каждая секция должна начинаться со специальной лексемы, свидетельствующей о начале блока комментария к
коду. У каждой секции должно быть имя, оно должно быть указано после лексемы, обозначающей начало блока комментария,
в той же строке. Затем может идти произвольный комментарий разработчика, поясняющий приведённый ниже код. Ниже
располагается блок кода. Пример:
```go
// @@docs Some title
// Some comment
func SomeFunc(someArg int) bool {
	...
}
```
Блок кода заканчивается либо, когда начинается следующая секция (и возобновляется после её закрытия), либо при
уменьшении отступа. Пример:
```go
// @@docs Section 1
// Some comment 1

... // <-- Code of section 1

func Section1Func(someArg int) bool { // <-- Code of section 1
	// @@docs Section 2
	// Some comment 2
	doSmth(someArg)      // <-- Code of section 2
	doSmthAgain(someArg) // <-- Code of section 2

        // @@docs Section 3
        // Some comment 3
        doSmth(someArg)      // <-- Code of section 3
        doSmthAgain(someArg) // <-- Code of section 3
} // <-- Code of section 1

... // <-- Code of section 1
```
Предусмотрены также специальные лексемы для ручного завершения блоков кода и комментария (`@@/code` и `@@/docs` соответственно).

#### Хранение секций

Для эффективного и удобного хранения объектов используется идея Git: от содержимого секции считается хэш, первые два
символа в шестнадцатеричном представлении этого хэша используются как имя папки, остальные — как имя файла.

Кроме того в системе используется подход хранения содержимого секций, подобный тому, что применяется в Git. В реализации
системы используются три вида объектов — _code_, _docs_ и _tree_:

- _code_ и _docs_ внутри устроены одинаково: 1 байт — тип, 4 байта — размер содержимого, дальше — содержимое.

<table>
  <tr>
    <th>Тип</th>
    <th colspan="4">Размер</th>
    <th colspan="4">Содержимое</th>
  </tr>
  <tr>
    <td>0x01</td>
    <td>0x00</td>
    <td>0x00</td>
    <td>0x00</td>
    <td>0x04</td>
    <td>0x96</td>
    <td>0xa8</td>
    <td>0x03</td>
    <td>0xfe</td>
  </tr>
</table>

- _tree_ внутри хранит информацию следующим образом: 1 байт — тип, 4 байта — размер содержимого, далее содержимое,
разделённое переносом строки (_tree_ хранит в себе “ссылки” на дочерние сущности) — 1 байт — тип, 32 байта — хэш,
далее — имя.

<table>
  <tr>
    <th rowspan="2">Тип</th>
    <th rowspan="2" colspan="4">Размер</th>
    <th colspan="11">Содержимое</th>
  </tr>
  <tr>
    <th>Тип</th>
    <th colspan="4">Хэш</th>
    <th colspan="4">Имя</th>
    <th>\n</th>
    <th>...</th>
  </tr>
  <tr>
    <td>0x02</td>
    <td>0x00</td>
    <td>0x00</td>
    <td>0x00</td>
    <td>0x29</td>
    <td>0x02</td>
    <td>0xa8</td>
    <td>0x03</td>
    <td>...</td>
    <td>0xfe</td>
    <td>0x91</td>
    <td>0x12</td>
    <td>...</td>
    <td>0xe8</td>
    <td>0x0a</td>
    <td>...</td>
  </tr>
</table>

#### Сравнение секций

Сравнение происходит лениво для повышения эффективности по времени и памяти.

1. Перед непосредственным сравнением секций делается два рекурсивных обхода: по исходному проекту и по сохранённым секциям.
    - Во время обхода проекта, секции не парсятся, а лишь запоминается время изменения файлов. Полученная информация
    сохраняется в виде префиксного дерева.
    - Аналогично во время обхода сохранённых секций в виде префиксного дерева сохраняются время модификации файла и хэши.
   
    Затем происходит первый этап сравнения — в деревьях проекта и секций сравниваются соответствующие узлы по времени модификации:
    если время изменения файла больше времени изменения секции, то файлу присваивается статус _probably modified_, иначе — _unmodified_.

    Если файла или секции нет в противоположном дереве, то таким секциям присваивается статус _created_ и _deleted_ соответственно.
2. Затем для _probably modified_ файлов происходит полное сравнение — секции парсятся, от их содержимого считается хэш
    и сравнивается с хэшем сохранённой секции. По результатам сравнения присваиваются следующие статусы:
   - _code outdated_: хэши блоков комментариев различаются, хэши блоков кода совпадают
   - _docs outdated_: хэши блоков кода различаются, хэши блоков комментариев совпадают
   - _modified_: хэши блоков кода различаются, хэши блоков комментариев различаются
   - _unmodified_: хэши блоков кода совпадают, хэши блоков комментариев совпадают
   - _created_: секция создана
   - _deleted_: секция удалена

В процессе первого и второго этапа сравнений строится единое префиксное дерево секций проекта на основе дерева сохранённых секций,
которое позже используется для сохранения состояния и генерации документации.

Весь процесс сравнения: парсинг, сравнение, сохранение — происходит асинхронно для повышения эффективности.

#### Генерация документации

На основе построенного на предыдущем этапе дереве формируется HTML файл документации, представляющий собой иерархическую сущность,
повторяющую структуру проекта. Названия секций являются гиперссылками, при нажатии на которые сервер загружает соответствующую документацию.

## Направления дальнейшей работы

- Оптимизация, эвристики, использование сжатия данных при хранении на диске
- Добавление в систему документации существующих Markdown файлов
- Генерация документации в виде Markdown файлов
- Возможность конфигурации синтаксиса и комментариев для неизвестных языков или систем
- Добавление команды для более детального просмотра изменений
